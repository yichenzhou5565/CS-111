Total: 3011 samples
    2868  95.3%  95.3%     3011 100.0% add_threads
      51   1.7%  96.9%       72   2.4% SortedList_lookup
      30   1.0%  97.9%       30   1.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:200
       9   0.3%  98.2%        9   0.3% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:165
       9   0.3%  98.5%        9   0.3% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1720
       8   0.3%  98.8%        8   0.3% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1721
       8   0.3%  99.1%       71   2.4% SortedList_insert
       7   0.2%  99.3%        7   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:203
       5   0.2%  99.5%        5   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:130
       4   0.1%  99.6%        4   0.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1730
       3   0.1%  99.7%        3   0.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:205
       3   0.1%  99.8%        3   0.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1729
       2   0.1%  99.9%        2   0.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:160
       2   0.1%  99.9%        2   0.1% _init
       1   0.0% 100.0%        1   0.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:134
       1   0.0% 100.0%        1   0.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:204
       0   0.0% 100.0%     3011 100.0% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:111
       0   0.0% 100.0%     3011 100.0% start_thread
ROUTINE ====================== add_threads in /u/eng/class/classfur/lab2_list.c
  2868   3011 Total samples (flat / cumulative)
     .      .  191:     fprintf(stderr, "Segmentation fault caught.\n");
     .      .  192:     exit(2);
     .      .  193: }
     .      .  194: 
     .      .  195: void* add_threads(void* tid)
---
     .      .  196: {
     .      .  197:     void* ret=NULL;
     .      .  198:     
     .      .  199:     int tmp = *((int*)tid);
     .      .  200:     
     .      .  201:     long i=0;
     .      .  202:     
     .      .  203:     /* Insert */
     .      .  204:     while(tmp<ele_num)
     .      .  205:     {
     1      1  206:         if (opt_syn == 'm')
     .      .  207:         {
     .      .  208:             pthread_mutex_lock(&mutex_lock);
     .      .  209:             SortedList_insert(head, &ele[tmp]);
     .      .  210:             pthread_mutex_unlock(&mutex_lock);
     .      .  211:         }
     .      .  212:         else if(opt_syn == 's')
     .      .  213:         {
  1086   1086  214:             while(__sync_lock_test_and_set(&spin_lock, 1));
     .     71  215:             SortedList_insert(head, &ele[tmp]);
     .      .  216:             __sync_lock_release(&spin_lock);
     .      .  217:         }
     .      .  218:         else
     .      .  219:         {
     .      .  220:             SortedList_insert(head, &ele[tmp]);
     .      .  221:         }
     .      .  222:         tmp = tmp+thr_num;
     .      .  223:     }
     .      .  224:     
     .      .  225:     i = 0;
     .      .  226:     /* length */
     .      .  227:     //long len = SortedList_length(head);
     .      .  228:     long len;
     .      .  229:     if (opt_syn == 'm')
     .      .  230:     {
     .      .  231:         pthread_mutex_lock(&mutex_lock);
     .      .  232:         len = SortedList_length(head);
     .      .  233:         pthread_mutex_unlock(&mutex_lock);
     .      .  234:     }
     .      .  235:     else if(opt_syn == 's')
     .      .  236:     {
     2      2  237:         while(__sync_lock_test_and_set(&spin_lock, 1));
     .      .  238:         len = SortedList_length(head);
     .      .  239:         __sync_lock_release(&spin_lock);
     .      .  240:     }
     .      .  241:     else
     .      .  242:     {
     .      .  243:         len = SortedList_length(head);
     .      .  244:     }
     .      .  245:     
     .      .  246:     if (len == -1)
     .      .  247:     {
     .      .  248:         fprintf(stdout, "Invalid length. List has already been corrupted.\n");
     .      .  249:         exit(2);
     .      .  250:     }
     .      .  251:     
     .      .  252:     /* Look-up and delete */
     .      .  253:     i = *((int*)tid);
     .      .  254:     SortedListElement_t* temp;
     .      .  255:     while(i<ele_num)
     .      .  256:     {
     .      .  257: //        temp = SortedList_lookup(head, ele[i].key);
     .      .  258: //        if (temp == NULL)
     .      .  259: //        {
     .      .  260: //            fprintf(stderr, "Element not found.\n");
     .      .  261: //            exit(2);
     .      .  262: //        }
     .      .  263: //        if (SortedList_delete(temp) != 0)
     .      .  264: //        {
     .      .  265: //            fprintf(stderr, "Deletion failed.\n");
     .      .  266: //            exit(2);
     .      .  267: //        }
     .      .  268:         
     .      .  269:         if (opt_syn == 'm')
     .      .  270:         {
     .      .  271:             pthread_mutex_lock(&mutex_lock);
     .      .  272:             temp = SortedList_lookup(head, ele[i].key);
     .      .  273:             if(temp == NULL)
     .      .  274:             {
     .      .  275:                 fprintf(stderr, "Look up failed.\n");
     .      .  276:                 exit(2);
     .      .  277:             }
     .      .  278:             if (SortedList_delete(temp)!=0)
     .      .  279:             {
     .      .  280:                 fprintf(stderr, "Deletion failed.\n");
     .      .  281:             }
     .      .  282:             pthread_mutex_unlock(&mutex_lock);
     .      .  283:         }
     .      .  284:         else if(opt_syn == 's')
     .      .  285:         {
  1779   1779  286:             while(__sync_lock_test_and_set(&spin_lock, 1));
     .     72  287:             temp = SortedList_lookup(head, ele[i].key);
     .      .  288:             if(temp == NULL)
     .      .  289:             {
     .      .  290:                 fprintf(stderr, "Look up failed.\n");
     .      .  291:                 exit(2);
     .      .  292:             }
     .      .  293:             if (SortedList_delete(temp)!=0)
     .      .  294:             {
     .      .  295:                 fprintf(stderr, "Deletion failed.\n");
     .      .  296:             }
     .      .  297:             __sync_lock_release(&spin_lock);
     .      .  298:         }
     .      .  299:         else
     .      .  300:         {
     .      .  301:             temp = SortedList_lookup(head, ele[i].key);
     .      .  302:             if(temp == NULL)
     .      .  303:             {
     .      .  304:                 fprintf(stderr, "Look up failed.\n");
     .      .  305:                 exit(2);
     .      .  306:             }
     .      .  307:             if (SortedList_delete(temp)!=0)
     .      .  308:             {
     .      .  309:                 fprintf(stderr, "Deletion failed.\n");
     .      .  310:             }
     .      .  311:         }
     .      .  312:         
     .      .  313:         i = i+thr_num;
     .      .  314:     }
     .      .  315:     
     .      .  316:     /* Unlock, if applicable */
     .      .  317: //    if (opt_syn == 'm')
     .      .  318: //        pthread_mutex_unlock(&mutex_lock);
     .      .  319: //    else if(opt_syn == 's')
     .      .  320: //        __sync_lock_release(&spin_lock);
     .      .  321:     
     .      .  322:     return ret;
     .      .  323: }
---
     .      .  324: 
     .      .  325: void output(struct timespec start, struct timespec end)
     .      .  326: {
     .      .  327:     long sec = end.tv_sec - start.tv_sec;
     .      .  328:     long nsec = end.tv_nsec - start.tv_nsec;
ROUTINE ====================== add_threads in /u/eng/class/classfur/lab2_list.c
  2868   3011 Total samples (flat / cumulative)
     .      .  191:     fprintf(stderr, "Segmentation fault caught.\n");
     .      .  192:     exit(2);
     .      .  193: }
     .      .  194: 
     .      .  195: void* add_threads(void* tid)
---
     .      .  196: {
     .      .  197:     void* ret=NULL;
     .      .  198:     
     .      .  199:     int tmp = *((int*)tid);
     .      .  200:     
     .      .  201:     long i=0;
     .      .  202:     
     .      .  203:     /* Insert */
     .      .  204:     while(tmp<ele_num)
     .      .  205:     {
     1      1  206:         if (opt_syn == 'm')
     .      .  207:         {
     .      .  208:             pthread_mutex_lock(&mutex_lock);
     .      .  209:             SortedList_insert(head, &ele[tmp]);
     .      .  210:             pthread_mutex_unlock(&mutex_lock);
     .      .  211:         }
     .      .  212:         else if(opt_syn == 's')
     .      .  213:         {
  1086   1086  214:             while(__sync_lock_test_and_set(&spin_lock, 1));
     .     71  215:             SortedList_insert(head, &ele[tmp]);
     .      .  216:             __sync_lock_release(&spin_lock);
     .      .  217:         }
     .      .  218:         else
     .      .  219:         {
     .      .  220:             SortedList_insert(head, &ele[tmp]);
     .      .  221:         }
     .      .  222:         tmp = tmp+thr_num;
     .      .  223:     }
     .      .  224:     
     .      .  225:     i = 0;
     .      .  226:     /* length */
     .      .  227:     //long len = SortedList_length(head);
     .      .  228:     long len;
     .      .  229:     if (opt_syn == 'm')
     .      .  230:     {
     .      .  231:         pthread_mutex_lock(&mutex_lock);
     .      .  232:         len = SortedList_length(head);
     .      .  233:         pthread_mutex_unlock(&mutex_lock);
     .      .  234:     }
     .      .  235:     else if(opt_syn == 's')
     .      .  236:     {
     2      2  237:         while(__sync_lock_test_and_set(&spin_lock, 1));
     .      .  238:         len = SortedList_length(head);
     .      .  239:         __sync_lock_release(&spin_lock);
     .      .  240:     }
     .      .  241:     else
     .      .  242:     {
     .      .  243:         len = SortedList_length(head);
     .      .  244:     }
     .      .  245:     
     .      .  246:     if (len == -1)
     .      .  247:     {
     .      .  248:         fprintf(stdout, "Invalid length. List has already been corrupted.\n");
     .      .  249:         exit(2);
     .      .  250:     }
     .      .  251:     
     .      .  252:     /* Look-up and delete */
     .      .  253:     i = *((int*)tid);
     .      .  254:     SortedListElement_t* temp;
     .      .  255:     while(i<ele_num)
     .      .  256:     {
     .      .  257: //        temp = SortedList_lookup(head, ele[i].key);
     .      .  258: //        if (temp == NULL)
     .      .  259: //        {
     .      .  260: //            fprintf(stderr, "Element not found.\n");
     .      .  261: //            exit(2);
     .      .  262: //        }
     .      .  263: //        if (SortedList_delete(temp) != 0)
     .      .  264: //        {
     .      .  265: //            fprintf(stderr, "Deletion failed.\n");
     .      .  266: //            exit(2);
     .      .  267: //        }
     .      .  268:         
     .      .  269:         if (opt_syn == 'm')
     .      .  270:         {
     .      .  271:             pthread_mutex_lock(&mutex_lock);
     .      .  272:             temp = SortedList_lookup(head, ele[i].key);
     .      .  273:             if(temp == NULL)
     .      .  274:             {
     .      .  275:                 fprintf(stderr, "Look up failed.\n");
     .      .  276:                 exit(2);
     .      .  277:             }
     .      .  278:             if (SortedList_delete(temp)!=0)
     .      .  279:             {
     .      .  280:                 fprintf(stderr, "Deletion failed.\n");
     .      .  281:             }
     .      .  282:             pthread_mutex_unlock(&mutex_lock);
     .      .  283:         }
     .      .  284:         else if(opt_syn == 's')
     .      .  285:         {
  1779   1779  286:             while(__sync_lock_test_and_set(&spin_lock, 1));
     .     72  287:             temp = SortedList_lookup(head, ele[i].key);
     .      .  288:             if(temp == NULL)
     .      .  289:             {
     .      .  290:                 fprintf(stderr, "Look up failed.\n");
     .      .  291:                 exit(2);
     .      .  292:             }
     .      .  293:             if (SortedList_delete(temp)!=0)
     .      .  294:             {
     .      .  295:                 fprintf(stderr, "Deletion failed.\n");
     .      .  296:             }
     .      .  297:             __sync_lock_release(&spin_lock);
     .      .  298:         }
     .      .  299:         else
     .      .  300:         {
     .      .  301:             temp = SortedList_lookup(head, ele[i].key);
     .      .  302:             if(temp == NULL)
     .      .  303:             {
     .      .  304:                 fprintf(stderr, "Look up failed.\n");
     .      .  305:                 exit(2);
     .      .  306:             }
     .      .  307:             if (SortedList_delete(temp)!=0)
     .      .  308:             {
     .      .  309:                 fprintf(stderr, "Deletion failed.\n");
     .      .  310:             }
     .      .  311:         }
     .      .  312:         
     .      .  313:         i = i+thr_num;
     .      .  314:     }
     .      .  315:     
     .      .  316:     /* Unlock, if applicable */
     .      .  317: //    if (opt_syn == 'm')
     .      .  318: //        pthread_mutex_unlock(&mutex_lock);
     .      .  319: //    else if(opt_syn == 's')
     .      .  320: //        __sync_lock_release(&spin_lock);
     .      .  321:     
     .      .  322:     return ret;
     .      .  323: }
---
     .      .  324: 
     .      .  325: void output(struct timespec start, struct timespec end)
     .      .  326: {
     .      .  327:     long sec = end.tv_sec - start.tv_sec;
     .      .  328:     long nsec = end.tv_nsec - start.tv_nsec;
